$date
	Thu Nov 11 01:37:39 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module datapath_tb $end
$var wire 1 ! TR_ZF $end
$var reg 32 " intTr [31:0] $end
$scope module DUV $end
$var wire 1 ! TR_ZF $end
$var wire 32 # intTr [31:0] $end
$var wire 32 $ c_res [31:0] $end
$var wire 3 % c_Sel [2:0] $end
$var wire 1 & c_RegWrite $end
$var wire 32 ' c_ReadData2 [31:0] $end
$var wire 32 ( c_ReadData1 [31:0] $end
$var wire 32 ) c_ReadData [31:0] $end
$var wire 32 * c_R [31:0] $end
$var wire 1 + c_MemToWrite $end
$var wire 1 , c_MemToReg $end
$var wire 3 - c_AluOp [2:0] $end
$var wire 1 . TR_zf $end
$scope module AluC_1 $end
$var wire 6 / func [5:0] $end
$var wire 3 0 AluOp [2:0] $end
$var reg 3 1 sel [2:0] $end
$upscope $end
$scope module Alu_1 $end
$var wire 3 2 sel [2:0] $end
$var wire 32 3 op2 [31:0] $end
$var wire 32 4 op1 [31:0] $end
$var reg 32 5 res [31:0] $end
$var reg 1 . zeroflag $end
$upscope $end
$scope module BR_1 $end
$var wire 5 6 ReadRegister1 [4:0] $end
$var wire 5 7 ReadRegister2 [4:0] $end
$var wire 5 8 WriteRegister [4:0] $end
$var wire 32 9 WriteData [31:0] $end
$var wire 1 & RegEn $end
$var reg 32 : ReadData1 [31:0] $end
$var reg 32 ; ReadData2 [31:0] $end
$upscope $end
$scope module Mem_1 $end
$var wire 32 < Adress [31:0] $end
$var wire 32 = WD [31:0] $end
$var wire 1 + EWR $end
$var reg 32 > ReadData [31:0] $end
$upscope $end
$scope module UC_1 $end
$var wire 6 ? op [5:0] $end
$var reg 3 @ AluOp [2:0] $end
$var reg 1 , MemToReg $end
$var reg 1 + Memtowrite $end
$var reg 1 & RegWrite $end
$upscope $end
$scope module mux21_1 $end
$var wire 32 A A [31:0] $end
$var wire 32 B B [31:0] $end
$var wire 1 , sel $end
$var reg 32 C R [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
x.
bx -
x,
x+
bx *
bx )
bx (
bx '
x&
bx %
bx $
bx #
bx "
z!
$end
#100
1&
b111 -
b111 0
b111 @
0+
0,
b1110010 '
b1110010 3
b1110010 ;
b1110010 =
b1000000 (
b1000000 4
b1000000 :
b0 ?
b111 6
b1010 7
b1000 8
b100000 /
b111010100100000000100000 "
b111010100100000000100000 #
#200
b0 (
b0 4
b0 :
b10010 6
b1001 8
b10010010100100100000100000 "
b10010010100100100000100000 #
#300
b1100011 '
b1100011 3
b1100011 ;
b1100011 =
b1110010 (
b1110010 4
b1110010 :
b10 6
b1011 7
b1010 8
b100100 /
b10010110101000000100100 "
b10010110101000000100100 #
#400
b0 '
b0 3
b0 ;
b0 =
b0 (
b0 4
b0 :
b11111 6
b11010 7
b1011 8
b11111110100101100000100100 "
b11111110100101100000100100 #
#500
b11110 6
b10100 7
b1100 8
b100010 /
b11110101000110000000100010 "
b11110101000110000000100010 #
#600
b1100001 (
b1100001 4
b1100001 :
b11 6
b1111 7
b1101 8
b11011110110100000100010 "
b11011110110100000100010 #
#700
b1000000 '
b1000000 3
b1000000 ;
b1000000 =
b0 (
b0 4
b0 :
b10001 6
b111 7
b1110 8
b100101 /
b10001001110111000000100101 "
b10001001110111000000100101 #
#800
bx '
bx 3
bx ;
bx =
b10101 6
b1011 7
b1111 8
b10101010110111100000100101 "
b10101010110111100000100101 #
#900
b0 '
b0 3
b0 ;
b0 =
bx (
bx 4
bx :
b10000 6
b10100 7
b10000 8
b10000101001000000000100101 "
b10000101001000000000100101 #
#1000
